<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Abstract Art</title>
    <script src="delaunator.js"></script>
<script>
"use strict";

var ctx = null
var MARGIN = 10
var WIDTH = null
var HEIGHT = null

function mdist(a, b) {
    return Math.max(Math.abs(a[0] - b[0]), Math.abs(a[1] - b[1]))
}
function dist(a, b) {
    var dx = a[0] - b[0], dy = a[1] - b[1]
    return Math.sqrt(dx*dx+dy*dy)
}

function start()
{
    setupMouseHandlers()
    ctx = canvas.getContext('2d')

    WIDTH = canvas.width - 2*MARGIN
    HEIGHT = canvas.height - 2*MARGIN

    col_points = [[0,0, 1,0,0], [1,0, 0,1,0], [1,1, 0,0,1], [0,1, 1,0,1]]  // x,y, r,b,g
    col_img = ctx.createImageData(WIDTH, HEIGHT);

    geom_change()
    col_change()
}

var points = []
var lines = []
var col_points = []
var col_lines = []
var col_img = null
var marked_col_point = null

function setupMouseHandlers()
{
    var mouseStart = null
    var selected_point = null
    var sel_col_point = null

    canvas.addEventListener("mousedown", function(e) {
        var x = (e.clientX - canvas.offsetLeft - MARGIN)/WIDTH
        var y = (e.clientY - canvas.offsetTop - MARGIN)/HEIGHT
        mouseStart = [x, y]

        // select point
        if (show_point_handles.checked) {
            selected_point = null
            for(var pi in points) {
                var p = points[pi]
                if (mdist(mouseStart, p) < 7/WIDTH) {
                    selected_point = p
                    break
                }
            }
        }
        if (show_col_point_handles.checked) {

        }
    })
    document.addEventListener("mouseup", function(e) {
        mouseStart = null
        selected_point = null
        sel_col_point = null
    })
    canvas.addEventListener("mousemove", function(e) {
        var x = (e.clientX - canvas.offsetLeft - MARGIN)/WIDTH
        var y = (e.clientY - canvas.offsetTop - MARGIN)/HEIGHT
        if (selected_point != null) {
            selected_point[0] = x
            selected_point[1] = y
            draw()
        }
    })
}

var rnd_state = 0
function rnd_seed(s) {
    rnd_state = s
}
function rnd_next() {
    rnd_state = (rnd_state * 1103515245 + 12345) % 2147483648
    return rnd_state / 2147483648
};

function nearest_neighbor_dist(ofp) {
    var min_d = Number.MAX_VALUE
    for(var pi in points) {
        var p = points[pi]
        if (p === ofp)
            continue
        var d = dist(p, ofp)
        if (d < min_d)
            min_d = d
    }
    return min_d
}

function triangles_lines(triangles, points) {
    var lines = []
    for (var i = 0; i < triangles.length; i += 3) {
        var p0 = points[ triangles[i] ];
        var p1 = points[ triangles[i + 1] ];
        var p2 = points[ triangles[i + 2] ];
        lines.push([p0,p1])
        lines.push([p1,p2])
        lines.push([p2,p0])
    }
    return lines
}


function geom_change()
{
    points = []
    lines = []

    if (geom_align_quad.checked)
    {
        var x_count = parseInt(aquads_xcount.value)
        var x_delta = 1 / (x_count)
        var y_count = parseInt(aquads_ycount.value)
        var y_delta = 1 / (y_count)
        var mat = []


        for(var xi = 0; xi <= x_count; ++xi) {
            var row = []
            for(var yi = 0; yi <= y_count; ++yi) {
                var p = [ xi*x_delta, yi*y_delta]
                points.push(p)
                row.push(p)
            }
            mat.push(row)
        }

        // connect points
        for(var xi = 0; xi <= x_count; ++xi) {
            for(var yi = 0; yi <= y_count; ++yi) {
                if (xi < x_count)
                    lines.push( [ mat[xi][yi], mat[xi+1][yi] ] )
                if (yi < y_count)
                    lines.push( [ mat[xi][yi], mat[xi][yi+1] ] )
            }
        }
    }
    else if (geom_tri.checked)
    {
        var p_count = parseInt(tri_count.value)
        if (p_count < 4)
            return
        var seed = parseInt(tri_seed.value)
        rnd_seed(seed)

        // https://bost.ocks.org/mike/algorithms/
        for(var pi = 0; pi < p_count; ++pi) {
            var bestCandidate, bestDistance = 0;
            for (var ti = 0; ti < 20; ++ti) {
                var c = [rnd_next(), rnd_next()],
                d = nearest_neighbor_dist(c);
                if (d > bestDistance) {
                    bestDistance = d;
                    bestCandidate = c;
                }
            }
            points.push(bestCandidate)
        }

        var delaunay = Delaunator.from(points)
        lines = triangles_lines(delaunay.triangles, points)

    }

    draw()
}

function vec_sub(a, b) {
    return [a[0]-b[0], a[1]-b[1]]
}
function cross(a, b) {
    return a[0]*b[1]-a[1]*b[0]
}
function dot(a, b) {
    return a[0]*b[0]+a[1]*b[1]
}
function col_mult(f, p) {
    return [f*p[2], f*p[3], f*p[4]]
}
function col_add3(a, b, c) {
    return [a[0]+b[0]+c[0], a[1]+b[1]+c[1], a[2]+b[2]+c[2]]
}

function col_change()
{
    var delaunay = Delaunator.from(col_points)
    var triangles = delaunay.triangles
    col_lines = triangles_lines(triangles, col_points)

    // prepare triangle vectors
    var tri_vecs = []  // list of tripets of vectors
    for (var i = 0; i < triangles.length; i += 3) {
        var A = col_points[ triangles[i] ];
        var B = col_points[ triangles[i + 1] ];
        var C = col_points[ triangles[i + 2] ];
        var AB = vec_sub(B,A)
        var AC = vec_sub(C,A)
        tri_vecs.push({A:A,B:B,C:C,AB:AB,AC:AC})
    }

    // draw pixels
    var dt = col_img.data;
    ctx.fillStyle = "#ff0000"

    //var tv = tri_vecs[0]

    for(var iy = 0; iy < HEIGHT; ++iy) {
        var y = iy / HEIGHT
        for(var ix = 0; ix < WIDTH; ++ix) {
            var x = ix / WIDTH
            var p = [x,y]

            for(var tvi in tri_vecs) {
                var tv = tri_vecs[tvi]
                var v0 = tv.AC
                var v1 = tv.AB
                var v2 = vec_sub(p, tv.A)

                var dot00 = dot(v0, v0)
                var dot01 = dot(v0, v1)
                var dot02 = dot(v0, v2)
                var dot11 = dot(v1, v1)
                var dot12 = dot(v1, v2)

                var invDenom = 1 / (dot00 * dot11 - dot01 * dot01)
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom

                if ((u >= 0) && (v >= 0) && (u + v < 1)) {
                    var w = 1 - u - v
                    var col = col_add3( col_mult(w, tv.A), col_mult(v, tv.B), col_mult(u, tv.C) )

                    var offset = 4*(iy*WIDTH+ix)
                    dt[offset] = col[0]*255;
                    dt[offset+1] = col[1]*255;
                    dt[offset+2] = col[2]*255;
                    dt[offset+3] = 255;

                    //ctx.fillRect( ix+MARGIN, iy+MARGIN, 1, 1 );
                }
            }
        }
    }

    //ctx.putImageData(col_img, MARGIN, MARGIN)

    draw()
}

function draw_points(points, col)
{
    ctx.fillStyle = col
    for(var pi in points) {
        var p = points[pi]
        ctx.beginPath();
        ctx.arc(p[0]*WIDTH+MARGIN, p[1]*HEIGHT+MARGIN, 4, 0, 2 * Math.PI, false);
        ctx.fill()
    }
}

function draw_lines(lines, col)
{
    ctx.strokeStyle = col
    ctx.beginPath()
    for(var li in lines) {
        var l = lines[li]
        ctx.moveTo(l[0][0]*WIDTH+MARGIN, l[0][1]*HEIGHT+MARGIN)
        ctx.lineTo(l[1][0]*WIDTH+MARGIN, l[1][1]*HEIGHT+MARGIN)
    }
    ctx.stroke()
}

function draw()
{
    ctx.fillStyle = 'white'
    ctx.fillRect(0, 0, canvas.width, canvas.height)
    ctx.putImageData(col_img, MARGIN, MARGIN)

    if (show_geom_lines.checked)
        draw_lines(lines, 'rgba(0,0,0,1)')

    if (show_point_handles.checked)
        draw_points(points, "rgba(255,20,20,0.6)")

    if (show_col_point_handles.checked)
        draw_points(col_points, "rgba(20,20,255,0.6)")

    if (show_col_lines.checked)
        draw_lines(col_lines, 'rgb(160,0,0,1)')

}


</script>
<style>
body {
    margin: 8px;
    -moz-user-select: -moz-none;
    -khtml-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
     user-select: none;
    background: #ffffff;
    font-family: Verdana;
}

#canvas {
    border: 1px solid #000000;
}
.num_input {
    width: 50px;
}

</style>
</head>
<body onload="start()">
    <canvas id="canvas" width="800" height="600"></canvas>
    <br>
    Show:
    <input id="show_geom_lines" type="checkbox" checke oninput="draw()">
    <label for="show_geom_lines">geom-lines</label>
    &nbsp;&nbsp;
    <input id="show_point_handles" type="checkbox" checke oninput="draw()">
    <label for="show_point_handles">points</label>
    &nbsp;&nbsp;
    <input id="show_col_point_handles" type="checkbox" checked oninput="draw()">
    <label for="show_col_point_handles">color-points</label>
    &nbsp;&nbsp;
    <input id="show_col_lines" type="checkbox" checked oninput="draw()">
    <label for="show_col_lines">color-lines</label>
    <br>
    <input id="geom_align_quad" type="radio" name="geom_sel" oninput="geom_change()" checked>
    <label for="geom_align_quad">Aligned Quads</label>
    &nbsp;&nbsp;&nbsp;&nbsp;
    x-count:<input id="aquads_xcount" class="num_input" type="number" value="15" oninput="geom_change()">
    y-count:<input id="aquads_ycount" class="num_input" type="number" value="10" oninput="geom_change()">
    <br>
    <input id="geom_tri" type="radio" name="geom_sel" oninput="geom_change()" checked>
    <label for="geom_tri">Triangles</label>
    &nbsp;&nbsp;&nbsp;&nbsp;
    point-count:<input id="tri_count" class="num_input" type="number" value="100" step="10" oninput="geom_change()">
    rand-seed:<input id="tri_seed" class="num_input" type="number" value="1" oninput="geom_change()">


</body>
</html>

